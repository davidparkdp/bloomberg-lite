// ─────────────────────────────────────────────────────────
// UPDATED SEQUENTIAL ENGINE
// ─────────────────────────────────────────────────────────

let globalTickerList = []; // Flattened list of all unique tickers
let tickerPointer = 0;     // Which ticker we are currently fetching
let isUpdating = false;

// 1. Initial Setup: Load structure, but don't fetch all prices at once
async function initialize() {
    buildChrome();
    await refreshStructure(); // Load CSVs and build the UI rows
    startSequentialUpdate();  // Start the "one-by-one" loop
    
    // Refresh the CSV structure every 5 minutes (in case you change tickers in Sheets)
    setInterval(refreshStructure, 300000); 
}

// 2. Load CSVs and build the UI (Prices will be blank/0 initially)
async function refreshStructure() {
    setStatus("Syncing Sheets...");
    const allTickersSet = new Set();

    for (let i = 0; i < SHEETS.length; i++) {
        const rows = await loadCSV(SHEETS[i].url);
        const pageEl = document.getElementById(`page-${i}`);
        
        // Build the panels for this page
        const frag = document.createDocumentFragment();
        PANELS.forEach(p => {
            // Modified buildPanelDOM to handle empty/initial state
            const node = buildInitialPanelDOM(rows, p); 
            if (node) frag.appendChild(node);
        });
        
        pageEl.innerHTML = "";
        pageEl.appendChild(frag);

        // Collect unique tickers for our global queue
        rows.forEach(r => {
            PANELS.forEach(p => {
                const t = r[p.tickerCol];
                if (t) allTickersSet.add(t);
            });
        });
    }

    globalTickerList = Array.from(allTickersSet);
    initialized = true;
    setStatus("Ready");
}

// 3. The "One-by-One" Loop
async function startSequentialUpdate() {
    if (isUpdating) return;
    isUpdating = true;

    while (true) {
        if (globalTickerList.length === 0) {
            await sleep(2000);
            continue;
        }

        const symbol = globalTickerList[tickerPointer];
        const data = await getQuote(symbol);

        if (data) {
            updateUIDisplay(symbol, data);
            document.getElementById("last-update").textContent = 
                `Last: ${symbol} @ ${new Date().toLocaleTimeString("en-US", { hour12: false })}`;
        }

        // Move to next ticker or loop back to start
        tickerPointer = (tickerPointer + 1) % globalTickerList.length;
        
        // Dynamic status
        setStatus(`Queue: ${tickerPointer + 1}/${globalTickerList.length}`);

        // WAIT before the next single call
        await sleep(CALL_DELAY_MS);
    }
}

// 4. Update every instance of a ticker across all pages
function updateUIDisplay(symbol, q) {
    const up = q.d >= 0;
    const colorClass = up ? "green" : "red";
    const sign = up ? "+" : "";

    // Find all rows across all pages that match this ticker
    const rows = document.querySelectorAll(`.row-ticker-${symbol.replace(/[^a-z0-9]/gi, '_')}`);
    
    rows.forEach(row => {
        row.className = `row ${colorClass} row-ticker-${symbol.replace(/[^a-z0-9]/gi, '_')} blink`;
        row.querySelector('.cell-price').textContent = q.c.toFixed(2);
        row.querySelector('.cell-chg').textContent = `${sign}${q.d.toFixed(2)}`;
        row.querySelector('.cell-pct').textContent = `${sign}${q.dp.toFixed(2)}%`;
        
        // Remove blink after animation
        setTimeout(() => row.classList.remove('blink'), 500);
    });
}

// Helper to build the UI before prices arrive
function buildInitialPanelDOM(rows, panel) {
    const { groupCol, tickerCol, nameCol } = panel;
    const items = rows
        .map(r => ({
            group:  r[groupCol]  || "",
            ticker: r[tickerCol] || "",
            name:   r[nameCol]   || ""
        }))
        .filter(r => r.group && r.ticker);

    if (!items.length) return null;

    const panelEl = document.createElement("div");
    panelEl.className = "panel";
    let lastGroup = null;

    items.forEach(item => {
        if (item.group !== lastGroup) {
            lastGroup = item.group;
            const g = document.createElement("div");
            g.className = "group";
            g.textContent = item.group;
            panelEl.appendChild(g);
        }

        const row = document.createElement("div");
        // Add a specific class so we can find this ticker later
        const tickerClass = `row-ticker-${item.ticker.replace(/[^a-z0-9]/gi, '_')}`;
        row.className = `row ${tickerClass}`;
        row.innerHTML = `
            <div class="cell-ticker">${item.ticker}</div>
            <div class="cell-name" title="${item.name}">${item.name}</div>
            <div class="cell-price">...</div>
            <div class="cell-chg"></div>
            <div class="cell-pct"></div>
        `;
        panelEl.appendChild(row);
    });

    return panelEl;
}

// Replace the end of your original script with:
buildChrome();
initialize();
