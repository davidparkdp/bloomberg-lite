<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Bloomberg Lite</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html { height: 100%; }
body {
    height: 100%;
    display: flex;
    flex-direction: column;
    background: #0a0a0a;
    color: #00ffcc;
    font-family: monospace;
    font-size: 13px;
}
.header {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    color: orange;
    padding: 6px 12px;
    border-bottom: 1px solid #333;
    background: #111;
}
.header-title { font-size: 14px; font-weight: bold; letter-spacing: 2px; }
.header-time  { color: #888; font-size: 11px; margin-left: auto; }
.tabs {
    flex-shrink: 0;
    display: flex;
    gap: 2px;
    padding: 4px 12px;
    background: #111;
    border-bottom: 1px solid #333;
}
.tab {
    padding: 3px 14px;
    cursor: pointer;
    border: 1px solid #444;
    color: #888;
    background: transparent;
    font-family: monospace;
    font-size: 11px;
    letter-spacing: 1px;
    transition: all .15s;
}
.tab.active { border-color: orange; color: orange; background: rgba(255,165,0,.08); }
.tab:hover:not(.active) { color: #ccc; border-color: #666; }
#pages {
    flex: 1 1 0;
    min-height: 0;
    position: relative;
}
.page {
    display: none;
    position: absolute;
    inset: 0;
    padding: 4px 6px;
}
.page.active { display: flex; }
.col {
    flex: 1;
    min-width: 0;
    overflow: hidden;
    padding: 0 3px;
    border-right: 1px solid #1a1a1a;
}
.col:first-child { padding-left: 0; }
.col:last-child  { border-right: none; padding-right: 0; }
.statusbar {
    flex-shrink: 0;
    background: #111;
    border-top: 1px solid #222;
    padding: 2px 12px;
    font-size: 10px;
    color: #555;
    display: flex;
    gap: 16px;
}
.statusbar span { color: #555; }
.status-warn { color: #ffaa00 !important; }

/* Column header row — fixed height, same as a data row.
   Always present as the first element in every column.
   Shows group name (grey, same font size) or is empty. */
.col-header {
    height: 21px;
    line-height: 21px;
    color: #888;
    font-size: 13px;
    font-family: monospace;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Data rows */
.row {
    display: grid;
    grid-template-columns: 48px 82px 66px 58px 56px 20px;
    height: 21px;
    align-items: center;
    gap: 1px;
    border-bottom: 1px solid #0f0f0f;
}
.row:hover { background: #141414; }

.cell-ticker { text-align: left; font-weight: bold; color: #ffb300; cursor: pointer; }
.cell-name {
    text-align: left; color: #ffb300; font-size: 11px;
    padding-right: 3px; overflow: hidden;
    text-overflow: ellipsis; white-space: nowrap;
    cursor: default; opacity: 0.85;
}
.cell-price { text-align: right; }
.cell-chg   { text-align: right; }
.cell-pct   { text-align: right; }
.cell-age   { text-align: right; font-size: 9px; color: #ffb300 !important; opacity: 0.6; }
.green { color: #00e676; }
.red   { color: #ff5252; }

/* Skeleton: before price loads */
.row.skeleton .cell-price,
.row.skeleton .cell-chg,
.row.skeleton .cell-pct { color: #222; }
</style>
</head>
<body>
<div class="header">
    <div class="header-title">◆ BLOOMBERG LITE</div>
    <div class="header-time" id="clock"></div>
</div>
<div class="tabs" id="tabs"></div>
<div id="pages"></div>
<div class="statusbar">
    <span id="status">Loading…</span>
    <span id="counter"></span>
</div>
<script>
const API_KEY       = "d6atqi1r01qnr27isiq0d6atqi1r01qnr27isiqg";
const CALL_DELAY_MS = 1200;
const PAUSE_ON_429  = 4000;
const NUM_COLS      = 5;
const SHEET_URL     = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT46q9pwRZMT27tLH6taYNgIYXFPkLdnjOhv3KqqGJGJY_Dn1SJ6yI4v1jaODaHy33TwbM-L5z14UWF/pub?gid=0&single=true&output=csv";

function parseCSV(text) {
    return text.trim().split("\n").map(line => {
        const fields = [];
        let cur = "", inQ = false;
        for (const ch of line) {
            if (ch === '"') { inQ = !inQ; }
            else if (ch === ',' && !inQ) { fields.push(cur.trim()); cur = ""; }
            else { cur += ch; }
        }
        fields.push(cur.trim());
        return fields;
    });
}
async function loadCSV(url) { return parseCSV(await (await fetch(url)).text()); }
const sleep = ms => new Promise(r => setTimeout(r, ms));

function setStatus(msg, warn=false) {
    const el = document.getElementById("status");
    el.textContent = msg;
    el.className = warn ? "status-warn" : "";
}
function setCounter(i, n) { document.getElementById("counter").textContent = `${i} / ${n}`; }
function updateClock() {
    const now = new Date();
    document.getElementById("clock").textContent =
        now.toLocaleDateString("en-US",{weekday:"short",month:"short",day:"numeric"})
        + "  " + now.toLocaleTimeString("en-US",{hour12:false});
}
setInterval(updateClock, 1000); updateClock();

function ageLabel(ts) {
    if (!ts) return "";
    const s = Math.floor((Date.now()-ts)/1000);
    if (s < 60) return s+"s";
    if (s < 3600) return Math.floor(s/60)+"m";
    return Math.floor(s/3600)+"h";
}

const quoteStore = {};
const tickerMeta = {};   // ticker → { group, name, pageIdx, colIdx }
let masterList = [];
let numPages = 0;
let dataRowsPerCol = 0;  // number of DATA rows per column (excludes header row)

// colHeaders[pageIdx][colIdx] = "GROUP NAME" or ""
let colHeaders = [];

async function loadUniqueItems() {
    const rows = await loadCSV(SHEET_URL);
    const maxCols = Math.max(...rows.map(r => r.length));
    const allItems = [];
    for (let base = 0; base + 1 < maxCols; base += 3) {
        rows.forEach(row => {
            const group  = row[base]   || "";
            const ticker = row[base+1] || "";
            const name   = row[base+2] || "";
            if (group && ticker) allItems.push({ group, ticker, name });
        });
    }
    const seen = new Set();
    return allItems.filter(item => {
        if (seen.has(item.ticker)) return false;
        seen.add(item.ticker);
        return true;
    });
}

function assignLayout(unique) {
    masterList = [];
    colHeaders = [];
    Object.keys(tickerMeta).forEach(k => delete tickerMeta[k]);

    const tickersPerPage = dataRowsPerCol * NUM_COLS;

    // First pass: figure out which group label goes in which column header.
    // A column header shows the group name of the FIRST ticker in that column,
    // but ONLY if this is the first-ever occurrence of that group globally.
    const groupFirstSeen = new Set();

    // We also need to track what group each column starts with,
    // so we can decide whether to show a label or leave it blank.
    const totalCols = Math.ceil(unique.length / dataRowsPerCol);
    const totalPages = Math.ceil(totalCols / NUM_COLS) || 1;

    for (let p = 0; p < totalPages; p++) {
        colHeaders[p] = [];
        for (let c = 0; c < NUM_COLS; c++) {
            const globalColIdx = p * NUM_COLS + c;
            const firstTickerIdx = globalColIdx * dataRowsPerCol;
            if (firstTickerIdx < unique.length) {
                const firstGroup = unique[firstTickerIdx].group;
                if (!groupFirstSeen.has(firstGroup)) {
                    groupFirstSeen.add(firstGroup);
                    colHeaders[p][c] = firstGroup;
                } else {
                    colHeaders[p][c] = "";
                }
            } else {
                colHeaders[p][c] = "";
            }
        }
    }

    // Now also check for mid-column group transitions — if a new group starts
    // partway through a column and it hasn't been seen yet, we need to mark
    // that first occurrence. But we show it in the column header only for the
    // first ticker. For mid-column new groups, we'll show an inline label.
    // Actually per the user's request, heading only appears at very start.
    // Let me reconsider: the user said "heading" = group name appearing only once.
    // Mid-column group changes just flow naturally without any label.
    // But we should still track groupFirstSeen for ALL groups, not just column-top ones.
    // Let's do a second pass to mark all groups as seen.
    unique.forEach(item => groupFirstSeen.add(item.group));

    // Second pass: assign each ticker to its position
    unique.forEach((item, idx) => {
        const globalCol = Math.floor(idx / dataRowsPerCol);
        const pageIdx = Math.floor(globalCol / NUM_COLS);
        const colIdx = globalCol % NUM_COLS;
        tickerMeta[item.ticker] = {
            group: item.group,
            name: item.name,
            pageIdx,
            colIdx
        };
        masterList.push(item.ticker);
    });

    numPages = totalPages;
}

function buildChrome() {
    const tabsEl = document.getElementById("tabs");
    const pagesEl = document.getElementById("pages");
    tabsEl.innerHTML = "";
    pagesEl.innerHTML = "";
    for (let i = 0; i < numPages; i++) {
        const tab = document.createElement("button");
        tab.className = "tab" + (i === 0 ? " active" : "");
        tab.textContent = `PAGE ${i+1}`;
        tab.onclick = () => switchPage(i);
        tabsEl.appendChild(tab);

        const page = document.createElement("div");
        page.className = "page" + (i === 0 ? " active" : "");
        page.id = `page-${i}`;
        for (let c = 0; c < NUM_COLS; c++) {
            const col = document.createElement("div");
            col.className = "col";
            col.id = `col-${i}-${c}`;

            // Header row — always present, same height as data row
            const hdr = document.createElement("div");
            hdr.className = "col-header";
            hdr.textContent = (colHeaders[i] && colHeaders[i][c]) || "";
            col.appendChild(hdr);

            page.appendChild(col);
        }
        pagesEl.appendChild(page);
    }
}

function renderAllSkeletons() {
    for (const ticker of masterList) {
        const meta = tickerMeta[ticker];
        if (!meta) continue;
        const colEl = document.getElementById(`col-${meta.pageIdx}-${meta.colIdx}`);
        if (!colEl) continue;
        const rowEl = document.createElement("div");
        rowEl.className = "row skeleton";
        rowEl.dataset.ticker = ticker;
        rowEl.innerHTML =
            `<div class="cell-ticker">${ticker}</div>` +
            `<div class="cell-name" title="${meta.name}">${meta.name}</div>` +
            `<div class="cell-price">—</div>` +
            `<div class="cell-chg"></div>` +
            `<div class="cell-pct"></div>` +
            `<div class="cell-age"></div>`;
        colEl.appendChild(rowEl);
    }
}

function renderTicker(ticker) {
    const q = quoteStore[ticker], meta = tickerMeta[ticker];
    if (!q || !meta) return;
    const colEl = document.getElementById(`col-${meta.pageIdx}-${meta.colIdx}`);
    if (!colEl) return;
    const rowEl = colEl.querySelector(`[data-ticker="${ticker}"]`);
    if (!rowEl) return;
    const up = q.d >= 0, color = up ? "green" : "red", sign = up ? "+" : "";
    rowEl.className = `row ${color}`;
    rowEl.innerHTML =
        `<div class="cell-ticker">${ticker}</div>` +
        `<div class="cell-name" title="${meta.name}">${meta.name}</div>` +
        `<div class="cell-price">${q.c.toFixed(2)}</div>` +
        `<div class="cell-chg">${sign}${q.d.toFixed(2)}</div>` +
        `<div class="cell-pct">${sign}${q.dp.toFixed(2)}%</div>` +
        `<div class="cell-age">${ageLabel(q.updatedAt)}</div>`;
}

function switchPage(idx) {
    document.querySelectorAll(".tab").forEach((t,i) => t.classList.toggle("active", i===idx));
    document.querySelectorAll(".page").forEach((p,i) => p.classList.toggle("active", i===idx));
}

// FIX #4: Clamped arrow keys — no wrapping
document.addEventListener("keydown", e => {
    if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
        const tabs = document.querySelectorAll(".tab");
        let cur = [...tabs].findIndex(t => t.classList.contains("active"));
        if (e.key === "ArrowRight" && cur < numPages - 1) switchPage(cur + 1);
        else if (e.key === "ArrowLeft" && cur > 0) switchPage(cur - 1);
    }
});

// Double-click ticker → Yahoo Finance
document.addEventListener("dblclick", e => {
    const cell = e.target.closest(".cell-ticker");
    const ticker = cell?.textContent?.trim();
    if (ticker) {
        window.open(
            `https://finance.yahoo.com/quote/${encodeURIComponent(ticker.toUpperCase())}/`,
            "_blank", "noopener,noreferrer"
        );
    }
});

// Age refresh
setInterval(() => {
    masterList.forEach(t => {
        const q = quoteStore[t], meta = tickerMeta[t];
        if (!q || !meta) return;
        const row = document.querySelector(`#col-${meta.pageIdx}-${meta.colIdx} [data-ticker="${t}"]`);
        const age = row?.querySelector(".cell-age");
        if (age) age.textContent = ageLabel(q.updatedAt);
    });
}, 30000);

async function fetchQuote(ticker) {
    const url = `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(ticker)}&token=${API_KEY}`;
    for (let attempt = 0; attempt < 5; attempt++) {
        try {
            const res = await fetch(url);
            if (res.status === 429) {
                setStatus("Rate limited — pausing…", true);
                await sleep(PAUSE_ON_429);
                continue;
            }
            if (!res.ok) return;
            const data = await res.json();
            if (data && data.c != null && data.c !== 0) {
                quoteStore[ticker] = { c:data.c, d:data.d, dp:data.dp, updatedAt:Date.now() };
                renderTicker(ticker);
            }
            return;
        } catch { await sleep(2000); }
    }
}

async function rollingLoop() {
    let idx = 0;
    while (true) {
        const t = masterList[idx];
        setStatus(`Fetching ${t}…`);
        setCounter(idx+1, masterList.length);
        await fetchQuote(t);
        await sleep(CALL_DELAY_MS);
        idx = (idx+1) % masterList.length;
    }
}

function fullRebuild(unique) {
    assignLayout(unique);
    buildChrome();
    renderAllSkeletons();
    for (const t of masterList) {
        if (quoteStore[t]) renderTicker(t);
    }
}

async function init() {
    setStatus("Reading sheet…");

    // Temp page for height measurement
    const tempPage = document.createElement("div");
    tempPage.className = "page active";
    tempPage.style.visibility = "hidden";
    document.getElementById("pages").appendChild(tempPage);

    const unique = await loadUniqueItems();

    const colH = tempPage.offsetHeight;
    document.getElementById("pages").removeChild(tempPage);

    // Row height = 21px. Reserve 1 row for the column header.
    const ROW_H = 21;
    const totalRows = Math.max(10, Math.floor(colH / ROW_H));
    dataRowsPerCol = totalRows - 1; // subtract 1 for the header row

    fullRebuild(unique);

    // After first paint, check if any column overflows and repack
    requestAnimationFrame(() => requestAnimationFrame(() => {
        const col0 = document.getElementById("col-0-0");
        if (col0 && col0.scrollHeight > col0.offsetHeight + 4) {
            const sampleRow = col0.querySelector(".row");
            if (sampleRow) {
                const actualRowH = sampleRow.offsetHeight;
                const hdrH = col0.querySelector(".col-header")?.offsetHeight || 21;
                const available = col0.offsetHeight - hdrH;
                dataRowsPerCol = Math.floor(available / actualRowH);
                fullRebuild(unique);
            }
        }
    }));

    rollingLoop();
}

init();
</script>
</body>
</html>
