<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Bloomberg Lite</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html { height: 100%; }
body {
    height: 100%;
    display: flex;
    flex-direction: column;
    background: #0a0a0a;
    color: #00ffcc;
    font-family: monospace;
    font-size: 13px;
}
.header {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    color: orange;
    padding: 6px 12px;
    border-bottom: 1px solid #333;
    background: #111;
}
.header-title { font-size: 14px; font-weight: bold; letter-spacing: 2px; }
.header-time  { color: #888; font-size: 11px; margin-left: auto; }
.tabs {
    flex-shrink: 0;
    display: flex;
    gap: 2px;
    padding: 4px 12px;
    background: #111;
    border-bottom: 1px solid #333;
    align-items: center;
}
.tab {
    padding: 3px 14px;
    cursor: pointer;
    border: 1px solid #444;
    color: #888;
    background: transparent;
    font-family: monospace;
    font-size: 11px;
    letter-spacing: 1px;
    transition: all .15s;
}
.tab.active { border-color: orange; color: orange; background: rgba(255,165,0,.08); }
.tab:hover:not(.active) { color: #ccc; border-color: #666; }

/* Search bar and sort */
.search-wrap {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 6px;
}
.search-wrap input {
    background: #1a1a1a;
    border: 1px solid #444;
    color: #ffb300;
    font-family: monospace;
    font-size: 12px;
    padding: 3px 8px;
    width: 180px;
    outline: none;
}
.search-wrap input:focus { border-color: orange; }
.search-wrap input::placeholder { color: #555; }
.search-info {
    color: #888;
    font-size: 10px;
    white-space: nowrap;
    min-width: 50px;
}
.sort-select {
    background: #1a1a1a;
    border: 1px solid #444;
    color: #888;
    font-family: monospace;
    font-size: 11px;
    padding: 3px 4px;
    outline: none;
    cursor: pointer;
}
.sort-select:focus { border-color: orange; }
.sort-select option { background: #1a1a1a; color: #ccc; }
/* Highlight for search matches */
.slot-data.search-match { background: rgba(255,165,0,.12); }
.slot-data.search-current { background: rgba(255,165,0,.35); }
#pages {
    flex: 1 1 0;
    min-height: 0;
    position: relative;
}
.page {
    display: none;
    position: absolute;
    inset: 0;
    padding: 4px 6px;
}
.page.active { display: flex; }
.col {
    flex: 1;
    min-width: 0;
    overflow: hidden;
    padding: 0 3px;
    border-right: 1px solid #1a1a1a;
}
.col:first-child { padding-left: 0; }
.col:last-child  { border-right: none; padding-right: 0; }
.statusbar {
    flex-shrink: 0;
    background: #111;
    border-top: 1px solid #222;
    padding: 2px 12px;
    font-size: 10px;
    color: #555;
    display: flex;
    gap: 16px;
}
.statusbar span { color: #555; }
.status-warn { color: #ffaa00 !important; }

/* Every element in a column is a .slot — fixed height */
.slot {
    height: 21px;
    line-height: 21px;
    overflow: hidden;
}
/* Group heading: same grid as data, text spans ticker+name area */
.slot-heading {
    color: #ddd;
    font-size: 13px;
    font-family: monospace;
    letter-spacing: 1px;
    text-transform: uppercase;
    white-space: nowrap;
    display: grid;
    grid-template-columns: 48px 82px 66px 58px 56px 20px;
    align-items: center;
    gap: 1px;
    border-bottom: 1px solid #0f0f0f;
}
/* Empty spacer */
.slot-empty {}
/* Data row */
.slot-data {
    display: grid;
    grid-template-columns: 48px 82px 66px 58px 56px 20px;
    align-items: center;
    gap: 1px;
    border-bottom: 1px solid #0f0f0f;
}
.slot-data:hover { background: #141414; }

.cell-ticker { text-align: left; font-weight: bold; color: #ffb300; cursor: pointer; }
.cell-name {
    text-align: left; color: #ffb300; font-size: 11px;
    padding-right: 3px; overflow: hidden;
    text-overflow: ellipsis; white-space: nowrap;
    cursor: default; opacity: 0.85;
}
.cell-price { text-align: right; }
.cell-chg   { text-align: right; }
.cell-pct   { text-align: right; }
.cell-age   { text-align: right; font-size: 9px; color: #ffb300 !important; opacity: 0.6; }
.green { color: #00e676; }
.red   { color: #ff5252; }
.slot-data.skeleton .cell-price,
.slot-data.skeleton .cell-chg,
.slot-data.skeleton .cell-pct { color: #222; }
</style>
</head>
<body>
<div class="header">
    <div class="header-title">◆ BLOOMBERG LITE</div>
    <div class="header-time" id="clock"></div>
</div>
<div class="tabs" id="tabs">
    <div class="search-wrap">
        <select id="sortSelect" class="sort-select">
            <option value="manual">Sort: Manual</option>
            <option value="alpha">Sort: A→Z</option>
            <option value="pct">Sort: % Chg</option>
        </select>
        <input type="text" id="searchInput" placeholder="Search ticker or name…" autocomplete="off" spellcheck="false">
        <span class="search-info" id="searchInfo"></span>
    </div>
</div>
<div id="pages"></div>
<div class="statusbar">
    <span id="status">Loading…</span>
    <span id="counter"></span>
</div>
<script>
const API_KEY       = "d6atqi1r01qnr27isiq0d6atqi1r01qnr27isiqg";
const CALL_DELAY_MS = 1200;
const PAUSE_ON_429  = 4000;
const NUM_COLS      = 5;
const SHEET_URL     = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT46q9pwRZMT27tLH6taYNgIYXFPkLdnjOhv3KqqGJGJY_Dn1SJ6yI4v1jaODaHy33TwbM-L5z14UWF/pub?gid=0&single=true&output=csv";

function parseCSV(text) {
    return text.trim().split("\n").map(line => {
        const fields = [];
        let cur = "", inQ = false;
        for (const ch of line) {
            if (ch === '"') { inQ = !inQ; }
            else if (ch === ',' && !inQ) { fields.push(cur.trim()); cur = ""; }
            else { cur += ch; }
        }
        fields.push(cur.trim());
        return fields;
    });
}
async function loadCSV(url) { return parseCSV(await (await fetch(url)).text()); }
const sleep = ms => new Promise(r => setTimeout(r, ms));

function setStatus(msg, warn=false) {
    const el = document.getElementById("status");
    el.textContent = msg;
    el.className = warn ? "status-warn" : "";
}
function setCounter(i, n) { document.getElementById("counter").textContent = `${i} / ${n}`; }
function updateClock() {
    const now = new Date();
    document.getElementById("clock").textContent =
        now.toLocaleDateString("en-US",{weekday:"short",month:"short",day:"numeric"})
        + "  " + now.toLocaleTimeString("en-US",{hour12:false});
}
setInterval(updateClock, 1000); updateClock();

function ageLabel(ts) {
    if (!ts) return "";
    const s = Math.floor((Date.now()-ts)/1000);
    if (s < 60) return s+"s";
    if (s < 3600) return Math.floor(s/60)+"m";
    return Math.floor(s/3600)+"h";
}

const quoteStore = {};
const tickerMeta = {};
let masterList = [];
let numPages = 0;
let slotsPerCol = 0;
let originalItems = [];  // preserved original order from CSV
let currentSort = "manual";

async function loadUniqueItems() {
    const rows = await loadCSV(SHEET_URL);
    const allItems = [];
    for (let i = 0; i < rows.length; i++) {
        const group  = (rows[i][0] || "").trim();
        const ticker = (rows[i][1] || "").trim();
        const name   = (rows[i][2] || "").trim();
        if (group && ticker) allItems.push({ group, ticker, name });
    }
    return allItems;
}

/*
 * Sort items within each group, preserving group order.
 * Returns a new array (does not mutate original).
 */
function sortItems(items, mode) {
    if (mode === "manual") return [...items];

    // Split into groups preserving order of first appearance
    const groupOrder = [];
    const groupMap = {};
    for (const item of items) {
        if (!groupMap[item.group]) {
            groupMap[item.group] = [];
            groupOrder.push(item.group);
        }
        groupMap[item.group].push({ ...item });
    }

    // Sort within each group
    for (const g of groupOrder) {
        const arr = groupMap[g];
        if (mode === "alpha") {
            arr.sort((a, b) => a.ticker.localeCompare(b.ticker));
        } else if (mode === "pct") {
            arr.sort((a, b) => {
                const apct = quoteStore[a.ticker]?.dp ?? -9999;
                const bpct = quoteStore[b.ticker]?.dp ?? -9999;
                return bpct - apct; // highest % change first
            });
        }
    }

    // Reassemble
    const result = [];
    for (const g of groupOrder) {
        result.push(...groupMap[g]);
    }
    return result;
}

/*
 * Build slot stream: headings inserted before first ticker of each group
 * (first occurrence only). Headings are just another slot in the sequence.
 */
function buildSlotStream(unique) {
    const slots = [];
    const groupSeen = new Set();
    for (const item of unique) {
        if (!groupSeen.has(item.group)) {
            groupSeen.add(item.group);
            slots.push({ type: "heading", text: item.group });
        }
        slots.push({ type: "data", ticker: item.ticker, name: item.name, group: item.group });
    }
    return slots;
}

/*
 * Pack slots into fixed-size columns.
 * Headings flow naturally wherever they land — multiple per column is fine.
 * Only rule: row 0 of every column must be heading or empty spacer.
 * Also: don't let a heading be the very last row of a column (orphaned).
 */
function packIntoColumns(slots) {
    const columns = [];
    let col = [];
    let si = 0;

    while (si < slots.length) {
        const posInCol = col.length;

        // Column is full — finalize and start new
        if (posInCol >= slotsPerCol) {
            columns.push(col);
            col = [];
            continue; // re-process current slot in new column
        }

        // Don't orphan a heading as the last row of a column
        if (slots[si].type === "heading" && posInCol === slotsPerCol - 1) {
            col.push({ type: "empty" });
            columns.push(col);
            col = [];
            continue; // heading will go into next column
        }

        // Normal: add the slot
        col.push(slots[si]);
        si++;
    }

    // Pad last column
    while (col.length < slotsPerCol) col.push({ type: "empty" });
    if (col.length > 0) columns.push(col);

    return columns;
}

function doLayout(unique) {
    masterList = [];
    Object.keys(tickerMeta).forEach(k => delete tickerMeta[k]);

    const slots = buildSlotStream(unique);
    const columns = packIntoColumns(slots);

    numPages = Math.ceil(columns.length / NUM_COLS) || 1;

    const layoutColumns = [];
    for (let p = 0; p < numPages; p++) {
        layoutColumns[p] = [];
        for (let c = 0; c < NUM_COLS; c++) {
            const gi = p * NUM_COLS + c;
            layoutColumns[p][c] = gi < columns.length
                ? columns[gi]
                : new Array(slotsPerCol).fill({ type: "empty" });
        }
    }

    for (let p = 0; p < numPages; p++) {
        for (let c = 0; c < NUM_COLS; c++) {
            for (const slot of layoutColumns[p][c]) {
                if (slot.type === "data") {
                    const idx = masterList.length;
                    masterList.push(slot.ticker);
                    tickerMeta[idx] = {
                        group: slot.group,
                        name: slot.name,
                        ticker: slot.ticker,
                        pageIdx: p,
                        colIdx: c
                    };
                }
            }
        }
    }

    return layoutColumns;
}

function buildChrome() {
    const tabsEl = document.getElementById("tabs");
    const pagesEl = document.getElementById("pages");
    // Remove only tab buttons, keep the search-wrap
    tabsEl.querySelectorAll(".tab").forEach(t => t.remove());
    pagesEl.innerHTML = "";
    const searchWrap = tabsEl.querySelector(".search-wrap");
    for (let i = 0; i < numPages; i++) {
        const tab = document.createElement("button");
        tab.className = "tab" + (i === 0 ? " active" : "");
        tab.textContent = `PAGE ${i+1}`;
        tab.onclick = () => switchPage(i);
        tabsEl.insertBefore(tab, searchWrap);
        const page = document.createElement("div");
        page.className = "page" + (i === 0 ? " active" : "");
        page.id = `page-${i}`;
        for (let c = 0; c < NUM_COLS; c++) {
            const col = document.createElement("div");
            col.className = "col";
            col.id = `col-${i}-${c}`;
            page.appendChild(col);
        }
        pagesEl.appendChild(page);
    }
}

function renderAllSlots(layoutColumns) {
    let slotIdx = 0;
    for (let p = 0; p < layoutColumns.length; p++) {
        for (let c = 0; c < layoutColumns[p].length; c++) {
            const colEl = document.getElementById(`col-${p}-${c}`);
            if (!colEl) continue;
            for (const slot of layoutColumns[p][c]) {
                const el = document.createElement("div");
                el.className = "slot";
                if (slot.type === "heading") {
                    el.classList.add("slot-heading");
                    el.innerHTML =
                        `<div style="grid-column:1/3;letter-spacing:1px;text-transform:uppercase">${slot.text}</div>` +
                        `<div></div><div></div><div></div><div></div>`;
                } else if (slot.type === "data") {
                    el.classList.add("slot-data", "skeleton");
                    el.dataset.slotId = slotIdx;
                    el.innerHTML =
                        `<div class="cell-ticker">${slot.ticker}</div>` +
                        `<div class="cell-name" title="${slot.name}">${slot.name}</div>` +
                        `<div class="cell-price">—</div>` +
                        `<div class="cell-chg"></div>` +
                        `<div class="cell-pct"></div>` +
                        `<div class="cell-age"></div>`;
                    slotIdx++;
                } else {
                    el.classList.add("slot-empty");
                }
                colEl.appendChild(el);
            }
        }
    }
}

function renderTicker(idx) {
    const meta = tickerMeta[idx];
    if (!meta) return;
    const ticker = meta.ticker;
    const q = quoteStore[ticker];
    if (!q) return;
    const colEl = document.getElementById(`col-${meta.pageIdx}-${meta.colIdx}`);
    if (!colEl) return;
    const rowEl = colEl.querySelector(`[data-slot-id="${idx}"]`);
    if (!rowEl) return;
    const up = q.d >= 0, color = up ? "green" : "red", sign = up ? "+" : "";
    rowEl.className = "slot slot-data " + color;
    rowEl.innerHTML =
        `<div class="cell-ticker">${ticker}</div>` +
        `<div class="cell-name" title="${meta.name}">${meta.name}</div>` +
        `<div class="cell-price">${q.c.toFixed(2)}</div>` +
        `<div class="cell-chg">${sign}${q.d.toFixed(2)}</div>` +
        `<div class="cell-pct">${sign}${q.dp.toFixed(2)}%</div>` +
        `<div class="cell-age">${ageLabel(q.updatedAt)}</div>`;
}

function switchPage(idx) {
    document.querySelectorAll(".tab").forEach((t,i) => t.classList.toggle("active", i===idx));
    document.querySelectorAll(".page").forEach((p,i) => p.classList.toggle("active", i===idx));
}

document.addEventListener("keydown", e => {
    // Don't switch pages if typing in search
    if (document.activeElement && document.activeElement.id === "searchInput") return;
    if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
        const tabs = document.querySelectorAll(".tab");
        let cur = [...tabs].findIndex(t => t.classList.contains("active"));
        if (e.key === "ArrowRight" && cur < numPages - 1) switchPage(cur + 1);
        else if (e.key === "ArrowLeft" && cur > 0) switchPage(cur - 1);
    }
});

document.addEventListener("dblclick", e => {
    const cell = e.target.closest(".cell-ticker");
    const ticker = cell?.textContent?.trim();
    if (ticker) {
        window.open(
            `https://finance.yahoo.com/quote/${encodeURIComponent(ticker.toUpperCase())}/`,
            "_blank", "noopener,noreferrer"
        );
    }
});

setInterval(() => {
    for (let i = 0; i < masterList.length; i++) {
        const meta = tickerMeta[i];
        const q = quoteStore[masterList[i]];
        if (!q || !meta) continue;
        const row = document.querySelector(`#col-${meta.pageIdx}-${meta.colIdx} [data-slot-id="${i}"]`);
        const age = row?.querySelector(".cell-age");
        if (age) age.textContent = ageLabel(q.updatedAt);
    }
}, 30000);

async function fetchQuote(ticker) {
    const url = `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(ticker)}&token=${API_KEY}`;
    for (let attempt = 0; attempt < 5; attempt++) {
        try {
            const res = await fetch(url);
            if (res.status === 429) { setStatus("Rate limited — pausing…", true); await sleep(PAUSE_ON_429); continue; }
            if (!res.ok) return;
            const data = await res.json();
            if (data && data.c != null && data.c !== 0) {
                quoteStore[ticker] = { c:data.c, d:data.d, dp:data.dp, updatedAt:Date.now() };
                // Update all slots that show this ticker
                for (let i = 0; i < masterList.length; i++) {
                    if (masterList[i] === ticker) renderTicker(i);
                }
            }
            return;
        } catch { await sleep(2000); }
    }
}

async function rollingLoop() {
    // Build a deduplicated fetch list (unique tickers only, in order of first appearance)
    const fetchList = [];
    const seen = new Set();
    for (const t of masterList) {
        if (!seen.has(t)) { seen.add(t); fetchList.push(t); }
    }
    let idx = 0;
    while (true) {
        const t = fetchList[idx];
        setStatus(`Fetching ${t}…`);
        setCounter(idx+1, fetchList.length);
        await fetchQuote(t);
        await sleep(CALL_DELAY_MS);
        idx = (idx+1) % fetchList.length;
    }
}

function fullRebuild(items) {
    const sorted = sortItems(items, currentSort);
    const layoutColumns = doLayout(sorted);
    buildChrome();
    renderAllSlots(layoutColumns);
    for (let i = 0; i < masterList.length; i++) {
        if (quoteStore[masterList[i]]) renderTicker(i);
    }
    // Re-apply search if active
    const q = document.getElementById("searchInput")?.value?.trim();
    if (q) doSearch(q);
}

/* ── Search ── */
let searchMatches = [];  // array of slot indices that match
let searchCursor = -1;   // current match index

function clearSearch() {
    document.querySelectorAll(".search-match, .search-current").forEach(el => {
        el.classList.remove("search-match", "search-current");
    });
    searchMatches = [];
    searchCursor = -1;
    document.getElementById("searchInfo").textContent = "";
}

function doSearch(query) {
    clearSearch();
    if (!query) return;
    const q = query.toLowerCase();

    // Find all matching slot indices
    for (let i = 0; i < masterList.length; i++) {
        const meta = tickerMeta[i];
        if (!meta) continue;
        const ticker = meta.ticker.toLowerCase();
        const name = meta.name.toLowerCase();
        if (ticker.includes(q) || name.includes(q)) {
            searchMatches.push(i);
            const el = document.querySelector(`[data-slot-id="${i}"]`);
            if (el) el.classList.add("search-match");
        }
    }

    if (searchMatches.length > 0) {
        searchCursor = 0;
        highlightCurrent();
    }
    updateSearchInfo();
}

function highlightCurrent() {
    // Remove previous current highlight
    document.querySelectorAll(".search-current").forEach(el => el.classList.remove("search-current"));
    if (searchCursor < 0 || searchCursor >= searchMatches.length) return;

    const idx = searchMatches[searchCursor];
    const meta = tickerMeta[idx];
    if (!meta) return;

    // Switch to the correct page
    switchPage(meta.pageIdx);

    // Highlight current match
    const el = document.querySelector(`[data-slot-id="${idx}"]`);
    if (el) el.classList.add("search-current");
}

function updateSearchInfo() {
    const info = document.getElementById("searchInfo");
    if (searchMatches.length === 0) {
        const q = document.getElementById("searchInput").value;
        info.textContent = q ? "0 results" : "";
    } else {
        info.textContent = `${searchCursor + 1} / ${searchMatches.length}`;
    }
}

function nextMatch() {
    if (searchMatches.length === 0) return;
    searchCursor = (searchCursor + 1) % searchMatches.length;
    highlightCurrent();
    updateSearchInfo();
}

function prevMatch() {
    if (searchMatches.length === 0) return;
    searchCursor = (searchCursor - 1 + searchMatches.length) % searchMatches.length;
    highlightCurrent();
    updateSearchInfo();
}

document.addEventListener("DOMContentLoaded", () => {
    const input = document.getElementById("searchInput");

    // Intercept Ctrl+F / Cmd+F to use custom search
    document.addEventListener("keydown", e => {
        if ((e.ctrlKey || e.metaKey) && e.key === "f") {
            e.preventDefault();
            input.focus();
            input.select();
        }
    });

    input.addEventListener("input", () => doSearch(input.value.trim()));
    input.addEventListener("keydown", e => {
        if (e.key === "Enter") {
            e.preventDefault();
            if (e.shiftKey) prevMatch();
            else nextMatch();
        }
        if (e.key === "Escape") {
            input.value = "";
            clearSearch();
            input.blur();
        }
    });
});

async function init() {
    setStatus("Reading sheet…");
    const tempPage = document.createElement("div");
    tempPage.className = "page active";
    tempPage.style.visibility = "hidden";
    document.getElementById("pages").appendChild(tempPage);

    originalItems = await loadUniqueItems();

    const colH = tempPage.offsetHeight;
    document.getElementById("pages").removeChild(tempPage);
    slotsPerCol = Math.max(10, Math.floor(colH / 21));

    fullRebuild(originalItems);

    requestAnimationFrame(() => requestAnimationFrame(() => {
        const col0 = document.getElementById("col-0-0");
        if (col0 && col0.scrollHeight > col0.offsetHeight + 4) {
            const sample = col0.querySelector(".slot");
            if (sample) {
                slotsPerCol = Math.floor(col0.offsetHeight / sample.offsetHeight);
                fullRebuild(originalItems);
            }
        }
    }));

    // Sort dropdown
    document.getElementById("sortSelect").addEventListener("change", e => {
        currentSort = e.target.value;
        fullRebuild(originalItems);
    });

    // Periodic re-sort for % change mode (every 30s as new prices arrive)
    setInterval(() => {
        if (currentSort === "pct") fullRebuild(originalItems);
    }, 30000);

    rollingLoop();
}

init();
</script>
</body>
</html>
