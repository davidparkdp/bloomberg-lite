<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Bloomberg Lite</title>
<style>
* { box-sizing: border-box; }
body {
    margin: 0;
    background: #0a0a0a;
    color: #00ffcc;
    font-family: monospace;
    font-size: 13px;
}

.header {
    display: flex;
    align-items: center;
    color: orange;
    padding: 8px 12px;
    border-bottom: 1px solid #333;
    background: #111;
}
.header-title { font-size: 15px; font-weight: bold; letter-spacing: 2px; }
.header-time  { color: #888; font-size: 12px; margin-left: auto; }

.tabs {
    display: flex;
    gap: 2px;
    padding: 6px 12px;
    background: #111;
    border-bottom: 1px solid #333;
}
.tab {
    padding: 4px 16px;
    cursor: pointer;
    border: 1px solid #444;
    color: #888;
    background: transparent;
    font-family: monospace;
    font-size: 12px;
    letter-spacing: 1px;
    transition: all .15s;
}
.tab.active { border-color: orange; color: orange; background: rgba(255,165,0,.08); }
.tab:hover:not(.active) { color: #ccc; border-color: #666; }

.page {
    display: none;
    padding: 10px 12px;
}
.page.active { display: flex; align-items: flex-start; }

.panel {
    flex: 1;
    min-width: 0;
    padding: 0 14px;
    border-right: 1px solid #222;
}
.panel:first-child { padding-left: 0; }
.panel:last-child  { border-right: none; }

.group {
    color: orange;
    margin-top: 16px;
    margin-bottom: 2px;
    font-size: 11px;
    letter-spacing: 1px;
    border-bottom: 1px solid #222;
    padding-bottom: 3px;
}
.group:first-child { margin-top: 4px; }

.row {
    display: grid;
    grid-template-columns: 55px 1fr 75px 68px 68px;
    padding: 3px 0;
    border-bottom: 1px solid #111;
    align-items: center;
}
.row:hover { background: #141414; }

.cell-ticker { text-align: left; font-weight: bold; }
.cell-name   { text-align: left; font-size: 11px; padding-right: 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.cell-price  { text-align: right; }
.cell-chg    { text-align: right; }
.cell-pct    { text-align: right; }

.green { color: #00e676; }
.red   { color: #ff5252; }

@keyframes blink-flash {
    0%   { opacity: 1; }
    40%  { opacity: 0.15; }
    100% { opacity: 1; }
}
.blink { animation: blink-flash .4s ease-out; }

.spinner { color: #444; padding: 40px 20px; letter-spacing: 2px; font-size: 12px; }

.statusbar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: #111;
    border-top: 1px solid #222;
    padding: 3px 12px;
    font-size: 11px;
    color: #555;
    display: flex;
    gap: 20px;
}
.statusbar span { color: #777; }
</style>
</head>
<body>

<div class="header">
    <div class="header-title">◆ BLOOMBERG LITE</div>
    <div class="header-time" id="clock"></div>
</div>

<div class="tabs" id="tabs"></div>
<div id="pages"></div>

<div class="statusbar">
    <span id="status">Loading…</span>
    <span id="last-update"></span>
</div>

<script>
// ─────────────────────────────────────────────────────────
// CONFIG
// ─────────────────────────────────────────────────────────
const API_KEY       = "d6atqi1r01qnr27isiq0d6atqi1r01qnr27isiqg";
const REFRESH_MS    = 60000;   // refresh every 60s (gives time to finish fetching)
const CALL_DELAY_MS = 1200;    // 1.2s between calls = 50/min, safely under limit

const SHEETS = [
    { label: "PAGE 1", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vT46q9pwRZMT27tLH6taYNgIYXFPkLdnjOhv3KqqGJGJY_Dn1SJ6yI4v1jaODaHy33TwbM-L5z14UWF/pub?gid=0&single=true&output=csv" },
    { label: "PAGE 2", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vT46q9pwRZMT27tLH6taYNgIYXFPkLdnjOhv3KqqGJGJY_Dn1SJ6yI4v1jaODaHy33TwbM-L5z14UWF/pub?gid=1898380729&single=true&output=csv" },
    { label: "PAGE 3", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vT46q9pwRZMT27tLH6taYNgIYXFPkLdnjOhv3KqqGJGJY_Dn1SJ6yI4v1jaODaHy33TwbM-L5z14UWF/pub?gid=710341566&single=true&output=csv" },
];

const PANELS = [
    { groupCol: 0, tickerCol: 1 },
    { groupCol: 2, tickerCol: 3 },
    { groupCol: 4, tickerCol: 5 },
];

// ─────────────────────────────────────────────────────────
// NAME CACHE — persists in memory for the session
// Company names never change so we only fetch them once
// ─────────────────────────────────────────────────────────
const nameCache = {};

function shortenName(raw) {
    let name = (raw || "").trim();
    name = name
        .replace(/ Inc\.?$/i, "").replace(/ Corp\.?$/i, "")
        .replace(/ Corporation$/i, "").replace(/ Ltd\.?$/i, "")
        .replace(/ Limited$/i, "").replace(/ Co\.?$/i, "")
        .replace(/ Holdings?$/i, "").replace(/ Group$/i, "")
        .replace(/ Technologies?$/i, " Tech")
        .replace(/ Pharmaceuticals?$/i, " Pharma")
        .replace(/ Therapeutics?$/i, " Tx")
        .replace(/ Biosciences?$/i, " Bio");
    return name.length > 18 ? name.slice(0, 17) + "…" : name;
}

// ─────────────────────────────────────────────────────────
// STRICT SERIAL QUEUE — one HTTP request at a time
// ─────────────────────────────────────────────────────────
let apiQueue = Promise.resolve();

// Wraps any async fn into the serial queue with delay + retry on 429
function enqueue(fn) {
    const p = apiQueue.then(async () => {
        await sleep(CALL_DELAY_MS);
        // Try up to 3 times with backoff if we still hit 429
        for (let attempt = 0; attempt < 3; attempt++) {
            try {
                const result = await fn();
                return result;
            } catch (e) {
                if (attempt < 2) await sleep(3000 * (attempt + 1));
            }
        }
        return null;
    });
    // Keep the queue chain going even if this slot throws
    apiQueue = p.then(() => {}, () => {});
    return p;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ─────────────────────────────────────────────────────────
// API CALLS
// ─────────────────────────────────────────────────────────
async function fetchQuote(symbol) {
    return enqueue(async () => {
        const res = await fetch(
            `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(symbol)}&token=${API_KEY}`
        );
        if (!res.ok) throw new Error(`${res.status}`);
        const data = await res.json();
        return (data && data.c != null && data.c !== 0) ? data : null;
    });
}

async function fetchName(symbol) {
    // Already cached — return immediately without using queue slot
    if (nameCache[symbol] !== undefined) return nameCache[symbol];

    return enqueue(async () => {
        const res = await fetch(
            `https://finnhub.io/api/v1/stock/profile2?symbol=${encodeURIComponent(symbol)}&token=${API_KEY}`
        );
        if (!res.ok) throw new Error(`${res.status}`);
        const data = await res.json();
        const name = shortenName(data.name);
        nameCache[symbol] = name;
        return name;
    });
}

// ─────────────────────────────────────────────────────────
// CSV LOADER
// ─────────────────────────────────────────────────────────
async function loadCSV(url) {
    const res  = await fetch(url);
    const text = await res.text();
    return text.trim().split("\n").map(r => r.split(",").map(c => c.trim()));
}

// Get all unique tickers from a parsed CSV across all panels
function extractTickers(rows) {
    const seen = new Set();
    const list = [];
    PANELS.forEach(p => {
        rows.forEach(row => {
            const t = row[p.tickerCol] || "";
            const g = row[p.groupCol]  || "";
            if (t && g && !seen.has(t)) { seen.add(t); list.push(t); }
        });
    });
    return list;
}

// ─────────────────────────────────────────────────────────
// CLOCK
// ─────────────────────────────────────────────────────────
function updateClock() {
    const now = new Date();
    document.getElementById("clock").textContent =
        now.toLocaleDateString("en-US", { weekday:"short", month:"short", day:"numeric" })
        + "  " + now.toLocaleTimeString("en-US", { hour12: false });
}
setInterval(updateClock, 1000);
updateClock();

// ─────────────────────────────────────────────────────────
// BUILD TABS + PAGE WRAPPERS
// ─────────────────────────────────────────────────────────
function buildChrome() {
    const tabsEl  = document.getElementById("tabs");
    const pagesEl = document.getElementById("pages");
    SHEETS.forEach((sheet, i) => {
        const tab = document.createElement("button");
        tab.className = "tab" + (i === 0 ? " active" : "");
        tab.textContent = sheet.label;
        tab.onclick = () => switchPage(i);
        tabsEl.appendChild(tab);

        const page = document.createElement("div");
        page.className = "page" + (i === 0 ? " active" : "");
        page.id = `page-${i}`;
        page.innerHTML = `<div class="spinner">LOADING…</div>`;
        pagesEl.appendChild(page);
    });
}

function switchPage(idx) {
    document.querySelectorAll(".tab").forEach((t, i) => t.classList.toggle("active", i === idx));
    document.querySelectorAll(".page").forEach((p, i) => p.classList.toggle("active", i === idx));
}

// ─────────────────────────────────────────────────────────
// BUILD PANEL DOM from pre-fetched data
// ─────────────────────────────────────────────────────────
function buildPanelDOM(rows, groupCol, tickerCol, quoteMap, nameMap) {
    const items = rows
        .map(r => ({ group: r[groupCol] || "", ticker: r[tickerCol] || "" }))
        .filter(r => r.group && r.ticker);
    if (!items.length) return null;

    const panel = document.createElement("div");
    panel.className = "panel";
    let lastGroup = null;

    items.forEach(item => {
        const q = quoteMap[item.ticker];
        if (!q) return;

        if (item.group !== lastGroup) {
            lastGroup = item.group;
            const g = document.createElement("div");
            g.className = "group";
            g.textContent = item.group;
            panel.appendChild(g);
        }

        const up    = q.d >= 0;
        const color = up ? "green" : "red";
        const sign  = up ? "+" : "";
        const name  = nameMap[item.ticker] || "";

        const row = document.createElement("div");
        row.className = `row ${color}`;
        row.innerHTML = `
            <div class="cell-ticker">${item.ticker}</div>
            <div class="cell-name">${name}</div>
            <div class="cell-price">${q.c.toFixed(2)}</div>
            <div class="cell-chg">${sign}${q.d.toFixed(2)}</div>
            <div class="cell-pct">${sign}${q.dp.toFixed(2)}%</div>
        `;
        panel.appendChild(row);
    });

    return panel;
}

// ─────────────────────────────────────────────────────────
// REFRESH ONE PAGE
// Each page: fetch names (cached after first time) then quotes
// ─────────────────────────────────────────────────────────
let initialized = false;

async function refreshPage(idx) {
    const rows    = await loadCSV(SHEETS[idx].url);
    const tickers = extractTickers(rows);
    const quoteMap = {};
    const nameMap  = {};

    // First pass: fetch any names not yet cached (only happens on very first load)
    const needNames = tickers.filter(t => nameCache[t] === undefined);
    if (needNames.length > 0) {
        setStatus(`Fetching names (${needNames.length} new)…`);
        // Kick off all name fetches — they're serialized by the queue internally
        await Promise.all(needNames.map(t => fetchName(t)));
    }

    // Copy cached names
    tickers.forEach(t => { nameMap[t] = nameCache[t] || ""; });

    // Second pass: fetch all quotes (always needed for fresh prices)
    for (const ticker of tickers) {
        setStatus(`Fetching ${ticker}…`);
        quoteMap[ticker] = await fetchQuote(ticker);
    }

    // Build and swap DOM
    const frag = document.createDocumentFragment();
    PANELS.forEach(p => {
        const node = buildPanelDOM(rows, p.groupCol, p.tickerCol, quoteMap, nameMap);
        if (node) frag.appendChild(node);
    });

    const pageEl = document.getElementById(`page-${idx}`);
    if (initialized) {
        pageEl.classList.add("blink");
        pageEl.addEventListener("animationend", () => pageEl.classList.remove("blink"), { once: true });
    }
    pageEl.innerHTML = "";
    pageEl.appendChild(frag);
}

// ─────────────────────────────────────────────────────────
// REFRESH ALL PAGES
// ─────────────────────────────────────────────────────────
async function refreshAll() {
    apiQueue = Promise.resolve(); // reset queue
    for (let i = 0; i < SHEETS.length; i++) {
        setStatus(`Loading page ${i + 1}…`);
        await refreshPage(i);
    }
    initialized = true;
    setStatus("OK");
    document.getElementById("last-update").textContent =
        "Updated " + new Date().toLocaleTimeString("en-US", { hour12: false });
}

function setStatus(msg) {
    document.getElementById("status").textContent = msg;
}

// ─────────────────────────────────────────────────────────
// INIT
// ─────────────────────────────────────────────────────────
buildChrome();
refreshAll();
setInterval(refreshAll, REFRESH_MS);
</script>
</body>
</html>
